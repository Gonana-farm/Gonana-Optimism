{
  "language": "Solidity",
  "sources": {
    "contracts/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {  Errors } from \"./utils/Errors.sol\";\n\n\n// LISK ADDRESS: 0x686690ef4a57F11A4980e0053E2D1EdD69782F35\ncontract Marketplace {\n\n    address private owner;\n\n\n    enum ProductState { Listed, Escrowed, Confirmed, Cancelled }\n\n    struct Product {\n        string productID;\n        uint256 amount;\n        address wallet;\n        string hash;\n        string merchantID;\n        ProductState state;\n    }\n\n    struct Order {\n        string productID;\n        uint256 amount;\n        address buyerAddress;\n        string buyerID;\n        // bool paid;\n    }\n\n    struct Redeem {\n        address id;\n        uint256 gas;\n    }\n\n    mapping(string => Product) public products;\n    mapping(string => Order) public orders;\n\n    Redeem[] claims ;\n\n    event ProductCreated(string productID, uint256 amount, address indexed seller);\n    // event ProductListed(string productID, uint256 amount, address seller);\n    event ProductListed(string productID, uint256 amount);\n    event ProductUnlisted(string productID);\n    event OrderPlaced(string productID, uint256 amount, address buyer);\n    event OrderConfirmed(string productID, address buyer);\n\n   \n\n    // modifier onlyProductState(string memory _productID, ProductState _requiredState) {\n    //     require(products[_productID].state == _requiredState, InvalidProductState());\n    //     _;\n    // }\n\n    //***** */ */\n\n    constructor(){\n        owner = msg.sender;\n    }\n\n    modifier onlySeller(string memory _productID) {\n        if (products[_productID].wallet == msg.sender){ \n            revert Errors.WrongSignature();\n        }\n        _;\n    }\n\n    modifier onlyBuyer(string memory _productID) {\n        if(orders[_productID].buyerAddress == msg.sender){ \n            revert Errors.WrongSignature();\n        }\n        _;\n    }\n\n    modifier onlyOwner() {\n        if(msg.sender != owner){\n            revert Errors.NotOwner();\n        }\n        _;\n    }\n\n\n    function createProduct(\n        string memory _productID, \n        uint256 _amount,\n        string memory _merchantID,\n        address creator\n    ) external onlyOwner {\n        if(products[_productID].wallet == address(0)){ revert Errors.ProductAlreadyExists();}\n        products[_productID] = Product(_productID, _amount, payable(creator), \"\", _merchantID, ProductState.Listed);\n        _listProduct(_productID,\"\");\n    }\n\n    function _listProduct(string memory _productID, string memory _hash) internal {\n        //require(products[_productID].state == ProductState.Listed, InvalidProductState());\n        products[_productID].hash = _hash;\n        products[_productID].state = ProductState.Listed;\n        // emit ProductListed(_productID, products[_productID].amount, msg.sender);\n        emit ProductListed(_productID, products[_productID].amount);\n    }\n\n    function unlistProduct(string memory _productID) external onlyOwner {\n        if(products[_productID].state == ProductState.Listed){ revert Errors.InvalidProductState();}\n        products[_productID].state = ProductState.Cancelled;\n        emit ProductUnlisted(_productID);\n    }\n\n    // function orderProduct(string memory _productID) external payable {\n    //     require(products[_productID].state == ProductState.Escrowed, \"Product not available\");\n    //     require(msg.value == products[_productID].amount, \"Incorrect amount sent\");\n    //     require(!orders[_productID].paid, \"Order already placed\");\n\n    //     orders[_productID] = Order(_productID, msg.value, payable(msg.sender), true);\n    //     products[_productID].seller.transfer(msg.value); // Send amount to the seller\n    //     emit OrderPlaced(_productID, msg.value, msg.sender);\n    // }\n\n    function orderProduct(\n        string memory _productID,\n        uint256 _amount,\n        string memory _buyerID\n    ) external payable {\n        //require(products[_productID], Errors.ProductNotFound());\n        if(products[_productID].state == ProductState.Listed) {revert Errors.InvalidProductState();}\n        // ensure the value inputed is same as the product amount listed\n        if(products[_productID].amount == _amount){ revert Errors.InvalidPrice();}\n        // ensure the value sent is the amount listed\n        if(msg.value == _amount){ revert Errors.InsufficientFunds();}\n\n        orders[_productID] = Order(_productID, _amount, msg.sender, _buyerID);\n        products[_productID].state = ProductState.Escrowed;\n        // escrow logic to hold funds until confirmed \n        //(transfer funds from the buyer to escrow account)\n        emit OrderPlaced(_productID, _amount, msg.sender);\n    } \n\n    function confirmOrder(string memory _productID) external onlyOwner {\n        //require(orders[_productID], Errors.OrderNotFound());\n        if(products[_productID].state == ProductState.Escrowed) {revert Errors.InvalidProductState();}\n        //require(orders[_productID].paid, \"No order placed\");\n\n        // logic to release funds in escrow account to seller\n\n        products[_productID].state = ProductState.Confirmed;\n        uint256 amount = products[_productID].amount;\n        (bool success,) = products[_productID].wallet.call{value:amount}(\"\");\n        if (!success) {\n            revert Errors.TransacationWasNotSuccessful();\n        }\n        emit OrderConfirmed(_productID, orders[_productID].buyerAddress);\n    }\n\n    function cancelOrder(string memory _productID) external onlyBuyer(_productID) {\n        //require(orders[_productID],  Errors.OrderNotFound);\n        if(products[_productID].state == ProductState.Escrowed) {revert Errors.InvalidProductState();}\n\n        // ensure funds are in escrow account\n        // require(orders[_productID].paid, \"No order placed\");\n\n        // Refund the buyer from escrow account\n        payable(msg.sender).transfer(orders[_productID].amount); \n        delete orders[_productID];\n        products[_productID].state = ProductState.Cancelled;\n    }\n\n    function changeOwner(address _owner) public onlyOwner {\n        assembly {\n            sstore(0x00, _owner)\n        }\n    }\n\n    function viewOrder(string memory _productID) external view returns (Order memory) {\n        return orders[_productID];\n    }\n\n    function viewProduct(string memory _productID) external view returns (Product memory) {\n        return products[_productID];\n    }\n\n\n}\n"
    },
    "contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.13;\n\n\nlibrary Errors{\n    error NotOwner();\n    error TransacationWasNotSuccessful();\n    error DepositDoesNotMatchAmount();\n    error ProductNotFound();\n    error ProductAlreadyExists();\n    error OrderNotFound();\n    error OrderAlreadyExists();\n    error InvalidProductState();\n    error InsufficientFunds();\n    error InvalidPrice();\n    // error NonceAlreadyUsed();\n    // error WrongContract();\n    error Expired();\n    error WrongFunctionCall();\n    error WrongSignature();\n    error DoNotHaveGasSpent();\n    \n\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}